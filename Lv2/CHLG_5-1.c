#include <stdio.h>

int n, m;						 // 교우 관계도에 나타난 사람의 수, 교우 관계도에 있는 관계의 수
int graph[501][101], visit[501]; // 인접 행렬과 방문 배열
int queue[501], rear, front;	 // 큐와 내부 변수
int cnt;						 // 문자 메시지를 보낼 수 있는 사람의 수

int BFS(int v) // BFS(넓이 우선 탐색) 연산
{
	int i;				// 정점을 나타내는 변수
	int A = 0;			// 친구의 친구까지만 연산하기 위한 변수
	visit[v] = 1;		// 정점 v를 방문 표시
	queue[rear++] = v;	// 큐에 v를 삽입하고 rear를 1 증가시킴
	v = queue[front++]; // 큐의 첫 번째에 있는 데이터를 가져오고 큐에서 삭제, front를 1 증가
	for (i = 1; i <= n; i++)
	{ // 모든 정점과의 관계를 확인할 때까지 반복
		if (visit[i] == 0 && graph[v][i] == 1)
		{					   // 정점 i를 방문하지 않고, 정점 v와 정점 i가 연결되어 있는 경우
			visit[i] = 1;	   // 정점 i를 방문 표시
			queue[rear++] = i; // 큐에 i를 삽입하고 rear를 1 증가시킴
			A++;			   // a를 1 증가시킴
			cnt++;			   // 사람 수 1 증가
		}
	}
	while (v <= A)
	{						// v가 a보다 작거나 같을 때 반복
		v = queue[front++]; // 큐의 첫 번째에 있는 데이터를 가져오고 큐에서 삭제, front를 1 증가
		for (i = 1; i <= n; i++)
		{ // 모든 정점과의 관계를 확인할 때까지 반복
			if (visit[i] == 0 && graph[v][i] == 1)
			{					   // 정점 i를 방문하지 않고, 정점 v와 정점 i가 연결되어 있는 경우
				visit[i] = 1;	   // 정점 i를 방문 표시
				queue[rear++] = i; // 큐에 i를 삽입하고 rear를 1 증가시킴
				cnt++;			   // 사람 수 1 증가
			}
		}
	}
}

int main()
{
	int a, b, i;			// 정점 입력 변수, 정점끼리의 관계를 입력받기 위한 변수
	scanf("%d %d", &n, &m); // 교우 관계도에 나타난 사람의 수, 교우 관계도에 있는 관계의 수를 입력받음
	for (i = 1; i <= m; i++)
	{								   // 모든 간선을 입력받을 때까지 반복
		scanf("%d %d", &a, &b);		   // 간선을 입력받음
		graph[a][b] = graph[b][a] = 1; // 인접 행렬에 간선 표시
	}
	BFS(1);			   // 1에서 BFS 시작
	printf("%d", cnt); // cnt 출력
}

/******************************************************************************
윤창호(장산중학교)
- 제출일 : 2015.11.3
- 소스코드 설명
	너비 우선 탐색을 활용했습니다.
	정점 1에 대해 1차적 관계를 가진 정점을 방문할 때마다 A포인터를 증가시켜
	그 정점의 관계까지만 확인할 수 있도록 작성했습니다.
- 성찰 일지
	이제 거의 마지막이네요. 그래프도 이해하는 데 오래 걸렸습니다.
	마지막 탐구과제도 열심히 해서 꼭 기한 내에 제출할 수 있도록 하겠습니다.
******************************************************************************/
